<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Optimisation Tools &mdash; FRED Tools 0.7.24 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=854f3c07"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Miscellaneous" href="misc.html" />
    <link rel="prev" title="Monte Carlo simulation tools" href="simTools.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #00007fff" >

          
          
          <a href="../index.html" class="icon icon-home">
            FRED Tools
              <img src="../_static/FREDtools_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.7.24
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../Introduction/Collaboration.html">Collaboration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Introduction/Citation.html">Citation and References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ReadWrite.html">Image Reading and Writing</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImageAnalyse.html">Image Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="spotAnalyse.html">Spot Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="dvhAnalyse.html">DVH Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="gammaIndexAnalyse.html">Gamma Index Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="braggPeakAnalyse.html">Bragg Peak Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="InmAnalyse.html">Influence Matrix Analyse</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingSubimage.html">Getting Subimage</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImageManipulate.html">Image Manipulate</a></li>
<li class="toctree-l1"><a class="reference internal" href="displayImage.html">Display Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="simTools.html">Monte Carlo simulation tools</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.convertCTtoWER"><code class="docutils literal notranslate"><span class="pre">convertCTtoWER()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.calcWETfromWER"><code class="docutils literal notranslate"><span class="pre">calcWETfromWER()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.generateIsoLayers"><code class="docutils literal notranslate"><span class="pre">generateIsoLayers()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.calcContours"><code class="docutils literal notranslate"><span class="pre">calcContours()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.convertRayTargetToIsoPlane"><code class="docutils literal notranslate"><span class="pre">convertRayTargetToIsoPlane()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositions"><code class="docutils literal notranslate"><span class="pre">optimiseBeamPositions()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositionsRegular"><code class="docutils literal notranslate"><span class="pre">optimiseBeamPositionsRegular()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositionsHexagonal"><code class="docutils literal notranslate"><span class="pre">optimiseBeamPositionsHexagonal()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #00007fff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FRED Tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Optimisation Tools</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Documentation/optimisationTools.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="optimisation-tools">
<h1>Optimisation Tools<a class="headerlink" href="#optimisation-tools" title="Link to this heading"></a></h1>
<p>A collection of functions useful for treatment plan optimisation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.convertCTtoWER">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">convertCTtoWER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HU</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">WER</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displayInfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.convertCTtoWER" title="Link to this definition"></a></dt>
<dd><p>Convert CT map to WER map.</p>
<p>The function converts a 3D Computed Tomography (CT) map with Houndsfield
Unit (HU) values, defined as a SimpleITK image object, to an image with
Water-Equivalent Ratio values (WER). The two parameters, <cite>HU</cite> and <cite>WER</cite>,
define the HU to WER conversion, whereas the missing HU values are interpolated
linearly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>SimpleITK Image</em>) – An object of a SimpleITK image with HU values.</p></li>
<li><p><strong>HU</strong> (<em>array_like</em>) – An iterable with HU values. It must be of the same size as WER.</p></li>
<li><p><strong>WER</strong> (<em>array_like</em>) – An iterable with WER values. It must be of the same size as HU.</p></li>
<li><p><strong>displayInfo</strong> (<em>bool</em><em>, </em><em>optional</em>) – Displays a summary of the function results. (def. False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of a SimpleITK image object with WER values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SimpleITK Image</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#fredtools.ft_optimisation.calcWETfromWER" title="fredtools.ft_optimisation.calcWETfromWER"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calcWETfromWER</span></code></a></dt><dd><p>calculate WET image from WER image for point-like source.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.calcWETfromWER">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">calcWETfromWER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgWER</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgMask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CPUNo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displayInfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.calcWETfromWER" title="Link to this definition"></a></dt>
<dd><p>Calculate WET image from WER image for point-like source.</p>
<p>The function calculates Water-Equivalent Thickness (WET) for each voxel of
an image defined as a SimpleITK image object containing Water-Equivalent
Ratio values (WER), inside a mask, defined as a SimpleITK image object describing
a binary mask. The WET values are calculated starting from a virtual source, located
at [X,Y]=[0,0] position and with Z position defined with a two-element <cite>SAD</cite>,
describing the source point in X and Y. Particularly, the WET is calculated for
a virtual source, where rays are deflected in X and Y directions in different
distances from the isocenter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgWER</strong> (<em>SimpleITK Image</em>) – An object of a SimpleITK image with WER values.</p></li>
<li><p><strong>SAD</strong> (<em>2-element array_like</em>) – Z coordinates of the virtual point source for deflection
in X and Y directions, respectively.</p></li>
<li><p><strong>imgMask</strong> (<em>SimpleITK Image</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An object of a SimpleITK image describing a binary mask, or None,
then all voxel positions will be calculated (def. None)</p></li>
<li><p><strong>CPUNo</strong> (<em>{'auto'</em><em>, </em><em>'none'}</em><em>, </em><em>scalar</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Define whether multiprocessing should be used and how many cores should
be exploited (def. ‘auto’). Can be None, then no multiprocessing will be used,
a string ‘auto’, then the number of cores will be determined by os.cpu_count(),
or a scalar defining the number of CPU cores to be used (def. ‘auto’).</p></li>
<li><p><strong>displayInfo</strong> (<em>bool</em><em>, </em><em>optional</em>) – Displays a summary of the function results. (def. False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of a SimpleITK image object with WET values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SimpleITK Image</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#fredtools.ft_optimisation.convertCTtoWER" title="fredtools.ft_optimisation.convertCTtoWER"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convertCTtoWER</span></code></a></dt><dd><p>convert CT map to WER map.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.generateIsoLayers">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">generateIsoLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minRange</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxRange</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beamParams</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.generateIsoLayers" title="Link to this definition"></a></dt>
<dd><p>Calculate iso-WET layers and corresponding energies.</p>
<p>The function calculates iso Water-Equivalent Thickness (WET) layers between
minimum and maximum range based on predefined parameters of the beam.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minRange</strong> (<em>scalar</em>) – Minimum range to calculate layers.</p></li>
<li><p><strong>maxRange</strong> (<em>scalar</em>) – Maximum range to calculate layers.</p></li>
<li><p><strong>beamParams</strong> (<em>pandas.DataFrame</em>) – Parameters of the beam, i.e. dependance of the
beam range and width with nominal energies. Must include
at least columns: “nomEnergy”, “rangeProx” and “rangeDist”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of pandas.DataFrame object describing the iso WET layers.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.calcContours">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">calcContours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgMask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">displayInfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.calcContours" title="Link to this definition"></a></dt>
<dd><p>Calculate contours from 2D binary mask.</p>
<p>The function calculates list of contours from a 2D image defined as
a SimpleITK image object describing a binary or floating mask, along
a level value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgMask</strong> (<em>SimpleITK Image</em>) – Object of a SimpleITK 2D image describing a binary mask.</p></li>
<li><p><strong>level</strong> (<em>scalar</em><em>, </em><em>optional</em>) – Value along which to find contours in the image. (def. 0.5)</p></li>
<li><p><strong>displayInfo</strong> (<em>bool</em><em>, </em><em>optional</em>) – Displays a summary of the function results. (def. False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of polygons defined as instances of shapely.polygon objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of shapely.polygon</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The imgMask must be a 2D image describing a floating or binary mask.
If an image is, for instance, a 3D image describing a slice, it must
be squeezed to 2D first. It can be done, for instance by slicing the image,
e.g. imgMask[:,:,0] for image where the third axis is single sized.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.convertRayTargetToIsoPlane">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">convertRayTargetToIsoPlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rayTarget</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.convertRayTargetToIsoPlane" title="Link to this definition"></a></dt>
<dd><p>Calculate beam positon in the isocentre plane.</p>
<p>The function calculates the beam positions in the isocentre plane,
based on the target position and distance to the virtual point (SAD).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rayTarget</strong> (<em>3xN array_like</em>) – Target positions in the format of 3xN iterable.</p></li>
<li><p><strong>SAD</strong> (<em>2-element array_like</em>) – Z coordinates of the virtual point source for deflection
in X and Y directions, respectively.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 3xN array with the ray position in the isocentre plane.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>3xN numpy array</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The function assumes that the beam goes along +Z direction.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.optimiseBeamPositions">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">optimiseBeamPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contourPolygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spotDistance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'regular'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.optimiseBeamPositions" title="Link to this definition"></a></dt>
<dd><p>Calculate and optimize the beam positions in a contour.</p>
<p>The function calculates optimized beam positions in a contour defined
as an instance of the shapely.Polygon object. Various optimization
algorithms are implemented. Refer to ‘See Also’ section to read more about
each algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contourPolygon</strong> (<em>shapely Polygon</em>) – Object of the shapely.Polygon.</p></li>
<li><p><strong>spotDistance</strong> (<em>scalar</em>) – The nominal spot distance is to be used to optimize the beam positions.
Depending on the algorithm, the distance between neighboring spots does
not have to be equal to this parameter. Therefore it describes only
the nominal distance.</p></li>
<li><p><strong>algorithm</strong> (<em>{'regular'</em><em>, </em><em>'hexagonal'</em><em>, </em><em>'concentric'</em><em>, </em><em>'delaunay'}</em><em>, </em><em>optional</em>) – Algorithm to be used to optimize the beam positions. Only ‘regular’
and ‘hexagonal’ are implemented so far. (def. ‘regular’)</p></li>
<li><p><strong>**kwargs</strong> (<em>keyword args</em><em>, </em><em>optional</em>) – Additional parameters are passed to the given optimization algorithm. Refer
to the given algorithm routine for more description. (def. None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Numpy array of size (Nx2) describing the position of N beams, where the first
column is X and the second Y directions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array (Nx2)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositionsRegular" title="fredtools.ft_optimisation.optimiseBeamPositionsRegular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimiseBeamPositionsRegular</span></code></a></dt><dd><p>Optimise beam positions in a regular grid.</p>
</dd>
<dt><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositionsHexagonal" title="fredtools.ft_optimisation.optimiseBeamPositionsHexagonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimiseBeamPositionsHexagonal</span></code></a></dt><dd><p>Optimise beam positions in a hexagonal grid.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.optimiseBeamPositionsRegular">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">optimiseBeamPositionsRegular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contourPolygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spotDistance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.optimiseBeamPositionsRegular" title="Link to this definition"></a></dt>
<dd><p>Calculate the beam positions using regular grid algorithm.</p>
<p>The function calculates beam positions in a contour defined
as an instance of the shapely.Polygon object using
regular grid algorithm. The algorithm is optimized to place
the central beam position at the polygon centroid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contourPolygon</strong> (<em>shapely Polygon</em>) – Object of the shapely.Polygon.</p></li>
<li><p><strong>spotDistance</strong> (<em>scalar</em>) – The spot distance to be used to calculate regular grid beam positions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Numpy array of size (Nx2) describing the position of N beams, where the first
column is X and the second Y directions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array (Nx2)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositions" title="fredtools.ft_optimisation.optimiseBeamPositions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimiseBeamPositions</span></code></a></dt><dd><p>Optimise beam positions using various algorithms.</p>
</dd>
</dl>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The regular grid algorithm distributes the beams with the same spacing in X and
Y directions. The grid size is calculated to fit the given contour polygon and is
moved so that the central beam is at the polygon centroid. All the beam positions
which are not inside the polygon are removed.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="fredtools.ft_optimisation.optimiseBeamPositionsHexagonal">
<span class="sig-prename descclassname"><span class="pre">fredtools.ft_optimisation.</span></span><span class="sig-name descname"><span class="pre">optimiseBeamPositionsHexagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contourPolygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spotDistance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'X'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fredtools.ft_optimisation.optimiseBeamPositionsHexagonal" title="Link to this definition"></a></dt>
<dd><p>Calculate the beam positions using the hexagonal grid algorithm.</p>
<p>The function calculates beam positions in a contour defined
as an instance of the shapely.Polygon object using
hexagonal grid algorithm. The algorithm is optimized to place
the central beam position at the polygon centroid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contourPolygon</strong> (<em>shapely Polygon</em>) – Object of the shapely.Polygon.</p></li>
<li><p><strong>spotDistance</strong> (<em>scalar</em>) – The spot distance is to be used to calculate regular grid beam positions.</p></li>
<li><p><strong>direction</strong> (<em>{'X'</em><em>, </em><em>'Y'}</em><em>, </em><em>optional</em>) – The direction along which the beams should be shifted to create a hexagonal
grid. This parameter can be used to align the hexagonal direction to the faster
direction of the pencil beam scanning. (def. ‘X’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Numpy array of size (Nx2) describing the position of N beams, where the first
column is X and the second Y directions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array (Nx2)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#fredtools.ft_optimisation.optimiseBeamPositions" title="fredtools.ft_optimisation.optimiseBeamPositions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimiseBeamPositions</span></code></a></dt><dd><p>Optimise beam positions using various algorithms.</p>
</dd>
</dl>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The hexagonal grid algorithm distributes the beams with the same spacing in X
(or in Y) and every second row (or column) of the beam positions is shifted by
half of the <cite>spotDistance</cite>. The grid size is calculated to fit the given
contour polygon and is moved so that the central beam is at the polygon centroid.
All the beam positions which are not inside the polygon are removed.</p>
<p>The user can choose in which direction, X or Y, the hexagonal grid should be aligned.
This might be important when optimizing the beam positions for a given machine where
the scanning is faster in one direction than in the other.</p>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="simTools.html" class="btn btn-neutral float-left" title="Monte Carlo simulation tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="misc.html" class="btn btn-neutral float-right" title="Miscellaneous" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright FRED collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>